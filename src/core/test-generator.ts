/**
 * Generates vitest type equality tests for zinfer.
 *
 * This module generates test files that verify zinfer-generated types
 * match z.input<typeof Schema> and z.output<typeof Schema>.
 */

import { basename } from "path";
import type { MappedTypeName } from "./types.js";

/**
 * Information about a schema for test generation.
 */
export interface TestSchemaInfo {
  /** Schema variable name (e.g., "UserSchema") */
  schemaName: string;
  /** Generated input type name (e.g., "UserInput") */
  inputTypeName: string;
  /** Generated output type name (e.g., "UserOutput") */
  outputTypeName: string;
}

/**
 * Information about a file for test generation.
 */
export interface TestFileInfo {
  /** Path to the schema source file (for import) */
  schemaFilePath: string;
  /** Path to the generated types file (for import) */
  typesFilePath: string;
  /** Unique prefix for this file's imports (e.g., "Basic" for basic-schema.ts) */
  importPrefix: string;
  /** Schemas in this file */
  schemas: TestSchemaInfo[];
}

/**
 * Options for test generation.
 */
export interface TestGeneratorOptions {
  /** Whether to include a file header comment */
  includeHeader?: boolean;
}

/**
 * Converts a kebab-case or snake_case string to PascalCase.
 */
export function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

/**
 * Generates a unique prefix from a file path.
 */
export function generateImportPrefix(filePath: string): string {
  const name = basename(filePath, ".ts");
  return toPascalCase(name);
}

/**
 * Creates TestSchemaInfo from schema name and mapped type names.
 */
export function createTestSchemaInfo(
  schemaName: string,
  mappedNames: MappedTypeName,
): TestSchemaInfo {
  return {
    schemaName,
    inputTypeName: mappedNames.inputName,
    outputTypeName: mappedNames.outputName,
  };
}

/**
 * Generates vitest type equality test file content.
 */
export class TestGenerator {
  private options: Required<TestGeneratorOptions>;

  constructor(options: TestGeneratorOptions = {}) {
    this.options = {
      includeHeader: options.includeHeader ?? true,
    };
  }

  /**
   * Generates the complete test file content.
   *
   * @param files - Array of file information for test generation
   * @returns Generated test file content
   */
  generate(files: TestFileInfo[]): string {
    if (files.length === 0) {
      return "";
    }

    const parts: string[] = [];

    // Header comment
    if (this.options.includeHeader) {
      parts.push(this.generateHeader());
      parts.push("");
    }

    // Core imports
    parts.push(this.generateCoreImports());
    parts.push("");

    // File-specific imports
    for (const file of files) {
      parts.push(this.generateFileImports(file));
      parts.push("");
    }

    // Test describe blocks
    parts.push(this.generateTestSuite(files));

    return parts.join("\n");
  }

  /**
   * Generates the header comment.
   */
  private generateHeader(): string {
    return `// This file is auto-generated by zinfer --generate-tests
// Do not edit manually. Regenerate with: zinfer --generate-tests [schema-files] --types-dir [types-dir] --out [output]`;
  }

  /**
   * Generates core import statements.
   */
  private generateCoreImports(): string {
    return `import { describe, it, expectTypeOf } from "vitest";
import type { z } from "zod";`;
  }

  /**
   * Generates import statements for a single file.
   */
  private generateFileImports(file: TestFileInfo): string {
    const lines: string[] = [];
    const fileLabel = basename(file.schemaFilePath).replace(/\.(ts|js)$/, "");

    lines.push(`// --- ${fileLabel} ---`);

    // Remove extension for imports (TypeScript/bundlers handle resolution)
    const schemaPath = file.schemaFilePath.replace(/\.(ts|js)$/, "");
    const typesPath = file.typesFilePath.replace(/\.(ts|js)$/, "");

    // Schema imports (runtime values with aliases)
    const schemaImports = file.schemas
      .map((s) => `${s.schemaName} as ${file.importPrefix}${s.schemaName}`)
      .join(", ");
    lines.push(`import { ${schemaImports} } from "${schemaPath}";`);

    // Type imports (with aliases)
    const typeImports = file.schemas.flatMap((s) => [
      `${s.inputTypeName} as ${file.importPrefix}${s.inputTypeName}`,
      `${s.outputTypeName} as ${file.importPrefix}${s.outputTypeName}`,
    ]);

    if (typeImports.length <= 2) {
      lines.push(`import type { ${typeImports.join(", ")} } from "${typesPath}";`);
    } else {
      lines.push(`import type {`);
      lines.push(`  ${typeImports.join(",\n  ")},`);
      lines.push(`} from "${typesPath}";`);
    }

    return lines.join("\n");
  }

  /**
   * Generates the test suite with all describe blocks.
   */
  private generateTestSuite(files: TestFileInfo[]): string {
    const describes = files.map((file) => this.generateFileDescribe(file)).join("\n\n");

    return `describe("Type equality tests", () => {
${describes}
});
`;
  }

  /**
   * Generates a describe block for a single file.
   */
  private generateFileDescribe(file: TestFileInfo): string {
    const fileLabel = basename(file.schemaFilePath, ".ts");
    const tests = file.schemas
      .map((s) => this.generateSchemaTests(file.importPrefix, s))
      .join("\n\n");

    return `  describe("${fileLabel}", () => {
${tests}
  });`;
  }

  /**
   * Generates test cases for a single schema.
   */
  private generateSchemaTests(prefix: string, schema: TestSchemaInfo): string {
    const prefixedSchema = `${prefix}${schema.schemaName}`;
    const prefixedInput = `${prefix}${schema.inputTypeName}`;
    const prefixedOutput = `${prefix}${schema.outputTypeName}`;

    return `    it("${schema.schemaName} input matches z.input", () => {
      expectTypeOf<${prefixedInput}>().toEqualTypeOf<z.input<typeof ${prefixedSchema}>>();
    });

    it("${schema.schemaName} output matches z.output", () => {
      expectTypeOf<${prefixedOutput}>().toEqualTypeOf<z.output<typeof ${prefixedSchema}>>();
    });`;
  }
}

/**
 * Convenience function to generate test file content.
 *
 * @param files - Array of file information for test generation
 * @param options - Generation options
 * @returns Generated test file content
 */
export function generateTypeTests(files: TestFileInfo[], options?: TestGeneratorOptions): string {
  const generator = new TestGenerator(options);
  return generator.generate(files);
}
